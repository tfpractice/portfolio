export const content = `
When designing business logic I focus on writing small code is flexible and extensible. This facilitates grouping related functionality and organically gives rise to new libraries.

This quality is exemplified in my work with graph algorithms which has been the basis for things ranging from connect four to gin rummy.`;

export const details = [
  { caption: 'leverages firebase and redux for integrated state management' },
  { caption: 'encapsulates separate game state between clients' },
  { caption: 'foolproof updates with zero intermediate state' },
];

export const C4details = [
  { caption: 'integrates redux and firebase authentication with redux store' },
  { caption: 'integrates react rendering with d3 visualization' },
  { caption: 'foolproof updates with zero intermediate state' },
];

export const info = {
  caption: `### Testable and flexible`,
  content: `I truly love programming, and I refactor obsessively. I focus on writing small, test-driven, functional code that is flexible and extensible. This facilitates grouping related functionality and organically gives rise to new libraries.

  This quality is exemplified in my work with graph algorithms, which I have rewritten no less than twenty times over three years, and have learned the most from. There is an [Object Oriented version](https://github.com/tfpractice/classical_graph_theory), designed for classical extension. [Factory Graph Theory](https://github.com/tfpractice/factory_graph_theory), which leverages the Factory design pattern to injection new sub-classes at runtime.  And Finally, [Graph Curry] (https://github.com/tfpractice/graph-curry) which does away with classes entirely and been my most successful version thus far. It has become the basis for a number of subsequent projects from [game boards](https://github.com/tfpractice/gamegrid) to [gin rummy](https://github.com/tfpractice/rummy-redux).`,
};
